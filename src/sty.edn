{ns sty

 env
 {:zen/tags #{zen/schema zen/tag}
  :zen/desc "Represents subject (server) under the testing"
  :type zen/map
  :keys {:base-url {:type zen/string}
         :tags {:type zen/set :every {:type zen/string}}
         :basic-auth {:type zen/map
                      :keys {:user {:type zen/string}
                             :password {:type zen/string}}}}}

 is-action
 {:zen/tags #{zen/tag}}

 action
 {:zen/tags #{zen/schema}
  :schema-key {:key :act}
  :require #{:act}
  :type zen/map
  :keys {:act {:type zen/symbol :tags #{is-action}}}}

 is-matcher
 {:zen/tags #{zen/tag}}

 matcher
 {:zen/tags #{zen/schema}
  :schema-key {:key :by}
  :type zen/map
  :require #{:by}
  :keys {:by {:type zen/symbol :tags #{is-matcher}}}
  :values {:type zen/any}}

 xstring
 {:zen/tags #{zen/schema}
  :type zen/case
  :case [{:when {:type zen/string}}
         {:when {:type zen/list}}]}

 http
 {:zen/tags #{is-action zen/schema}
  :type zen/map
  :require #{:method :url} ;;#{:get :put :post :patch :delete}
  :keys {:method {:type zen/keyword :enum [{:value :post}
                                           {:value :put}
                                           {:value :get}
                                           {:value :delete}
                                           {:value :option}
                                           {:value :patch}]}
         :url    {:confirms #{xstring}}
         :params {:type zen/map :values {:confirms #{xstring}}}
         :headers {:type zen/map :values {:confirms #{xstring}}}
         :body {:type zen/any}

         ;; :get {:type zen/string}
         ;; :post {:type zen/string}
         ;; :put {:type zen/string}
         }}

 print
 {:zen/tags #{is-action zen/schema}
  :type zen/map
  :keys {:expression {:type zen/list}
         :path {:type zen/vector}}}

 matcho
 {:zen/tags #{is-matcher zen/schema}
  :zen/desc "Matcho engine"
  :type zen/map
  :values {:type zen/any}}

 step
 {:zen/tags #{zen/schema}
  :type zen/map
  :keys {:id      {:type zen/keyword}
         :desc    {:type zen/string}
         :tags    {:type zen/set :every {:type zen/string}}
         :do      {:confirms #{action}}
         :match   {:confirms #{matcher}}}}

 case
 {:zen/tags #{zen/schema zen/tag}
  :type zen/map
  :keys {:title {:type zen/string}
         :tags  {:type zen/set :every {:type zen/string}}
         :steps {:type zen/vector
                 :every {:confirms #{step}}}}}

 predicate {:zen/tags #{zen/tag}}

 string? {:zen/tags #{predicate}}

 number? {:zen/tags #{predicate}}

 integer? {:zen/tags #{predicate}}

 ok? {:zen/tags #{predicate}}

 any? {:zen/tags #{predicate}}

 is-event {:zen/tags #{zen/tag}}

 event
 {:zen/tags #{zen/schema}
  :type zen/map
  :keys {:type {:type zen/symbol
                :tags #{is-event}
                :zen/desc "Event type, i.e. sty/on-tests-start"}
         :ts {:type zen/integer :zen/desc "Number of milliseconds from start"}}}

 on-tests-start
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests starts"
  :confirms #{event}
  :type zen/map
  :keys {}}

 on-tests-end
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests end"
  :confirms #{event}
  :type zen/map
  :keys {}}

 on-case-start
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests finish"
  :confirms #{event}
  :type zen/map
  :keys {:env {:confirms #{env}}
         :case {:confirms #{case}}}}

 on-case-end
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests finish"
  :confirms #{event on-step-start}
  :type zen/map
  :keys {:result {:type zen/any}
         :errors {:type zen/any}}}

 on-step-start
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests finish"
  :confirms #{event}
  :type zen/map
  :keys {:env {:confirms #{env}}
         :case {:confirms #{case}}
         :step {:confirms #{step}}}}

 on-step-end
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests finish"
  :confirms #{event on-step-start}
  :type zen/map
  :keys {:result {:type zen/any}
         :errors {:type zen/any}}}

 op  {:zen/tags #{zen/tag zen/schema}
      :type zen/map
      :keys {:params {:confirms #{zen/schema}}
             :result {:confirms #{zen/schema}}}}

 echo {:zen/tags #{op} :zen/desc "echo operation to test rpc api"}

 get-namespaces {:zen/tags #{op} :zen/desc "get namespaces with cases to run on UI"}

 get-case {:zen/tags #{op}
           :zen/desc "get stresty case to run on UI"
           :params {:type zen/map
                    :keys {:case {:type zen/string}}}}

 run-tests
 {:zen/tags #{op}
  :zen/desc "Run selected tests"
  :params {:type zen/map
           :keys {:tags    {:type zen/set    :every {:type zen/string}}
                  :pattern {:type zen/string}}}}

 run-cases
 {:zen/tags #{op}
  :zen/desc "Run specific cases"
  :params {:type zen/map
           :keys {:cases  {:type zen/vector :every {:type zen/symbol :tags #{case}}}
                  :envs {:type zen/vector :every {:type zen/symbol :tags #{env}}}
                  :tags {:type zen/set :every {:type zen/string}}}}}

 run-steps
 {:zen/tags #{op}
  :zen/desc "Run specific cases"
  :params {:type zen/map
           :keys {:envs {:type zen/vector :every {:type zen/symbol :tags #{env}}}
                  :case   {:type zen/symbol :tags #{case}}
                  :tags   {:type zen/set :every {:type zen/string}}
                  :steps  {:type zen/vector :every {:type zen/keyword}}}}}

 gen
 {:zen/tags #{op}
  :zen/desc "Generates"
  :params {:type zen/map
           :keys {:project {:type zen/string}}}}

 rest-op  {:zen/tags #{zen/tag}}
 index-op {:zen/tags #{rest-op}}

 rpc-op   {:zen/tags #{rpc-op}
           :zen/desc "rpc endpoint, accept json and transit formats trho content-type header"}

 get-rpc-op   {:zen/tags #{rpc-op}
               :zen/desc "rpc endpoint, accept json and transit formats trho content-type header"}

 api
 {:zen/desc "Server routes"
  :static-dir "static"
  :routes {:get index-op
           "rpc" {:post rpc-op
                  :get  get-rpc-op}}}
 cli
 {:zen/desc "CLI interface"}

 cli-cmd
 {:zen/tags #{zen/tag zen/schema}
  :type zen/map
  :keys {:cli/name {:type zen/string :zen/desc "Command name"}
         :params {:confirms #{zen/schema}
                  :type zen/map
                  :keys {:keys {:type zen/map
                                :values {:type zen/map
                                         :keys {:cli/name  {:type zen/string :zen/desc "Command name"}
                                                :cli/alias {:type zen/string}}}}}
                  }}}

 cli-gen
 {:zen/tags #{cli-cmd}
  :cli/name "gen"
  :params {:type zen/map
           :require #{:project}
           :keys {:project {:type zen/string
                            :zen/desc "name of project"
                            :cli/alias "pr"}}}}

 cli-check
 {:zen/tags #{cli-cmd}
  :cli/name "check"
  :params {:type zen/map
           :require #{:project}
           :keys {:ns {:type zen/vector
                       :zen/desc "Namespaces to check"
                       :every {:type zen/string}}}}}

 cli-server
 {:zen/tags #{cli-cmd}
  :cli/name "server"
  :params {:type zen/map
           :require #{:project}
           :keys {:port {:type zen/integer
                         :zen/desc "Port to start server"
                         :cli/alias "p"}}}}

 cli-test
 {:zen/tags #{cli-cmd}
  :cli/name "test"
  :params {:type zen/map
           :require #{:project}
           :keys {:tag {:type zen/vector
                        :zen/desc "tags list, run only cases and envs with this tags"
                        :cli/alias "tg"
                        :every {:type zen/string}}
                  :case {:type zen/vector
                         :zen/desc "cases list, run only listed cases"
                         :cli/alias "cs"
                         :every {:type zen/string}}
                  :env {:type zen/vector
                        :zen/desc "envs list, run specific enviroments"
                        :cli/alias "e"
                        :every {:type zen/string}}}}}



 }
