{ns sty

 env
 {:zen/tags #{zen/schema zen/tag}
  :zen/desc "Represents subject (server) under the testing"
  :type zen/map
  :keys {:base-url {:type zen/string}
         :tags {:type zen/set :every {:type zen/string}}
         :basic-auth {:type zen/map
                      :keys {:user {:type zen/string}
                             :password {:type zen/string}}}}}

 is-action
 {:zen/tags #{zen/tag}}

 action
 {:zen/tags #{zen/schema}
  :schema-key {:key :act}
  :require #{:act}
  :type zen/map
  :keys {:act {:type zen/symbol :tags #{is-action}}}}

 is-matcher
 {:zen/tags #{zen/tag}}

 matcher
 {:zen/tags #{zen/schema}
  :schema-key {:key :by}
  :type zen/map
  :require #{:by}
  :keys {:by {:type zen/symbol :tags #{is-matcher}}}
  :values {:type zen/any}}

 http
 {:zen/tags #{is-action zen/schema}
  :type zen/map
  :require #{:method :url} ;;#{:get :put :post :patch :delete}
  :keys {:method {:type zen/keyword :enum [{:value :post}
                                           {:value :put}
                                           {:value :get}
                                           {:value :delete}
                                           {:value :option}
                                           {:value :patch}]}
         :url    {:type zen/string}
         :params {:type zen/map :values {:type zen/string}}
         :headers {:type zen/map :values {:type zen/string}}
         :body {:type zen/any}

         ;; :get {:type zen/string}
         ;; :post {:type zen/string}
         ;; :put {:type zen/string}
         }}

 print
 {:zen/tags #{is-action zen/schema}
  :type zen/map
  :keys {:expression {:type zen/list}
         :path {:type zen/vector}}}

 matcho
 {:zen/tags #{is-matcher zen/schema}
  :zen/desc "Matcho engine"
  :type zen/map
  :values {:type zen/any}}

 step
 {:zen/tags #{zen/schema}
  :type zen/map
  :keys {:desc    {:type zen/string}
         :tags    {:type zen/set :every {:type zen/string}}
         :do      {:confirms #{action}}
         :match   {:confirms #{matcher}}}}

 case
 {:zen/tags #{zen/schema zen/tag}
  :type zen/map
  :keys {:title {:type zen/string}
         :tags  {:type zen/set :every {:type zen/string}}
         :steps {:type zen/map
                 :values {:confirms #{step}}}}}

 predicate {:zen/tags #{zen/tag}}

 string? {:zen/tags #{predicate}}

 number? {:zen/tags #{predicate}}

 integer? {:zen/tags #{predicate}}

 ok? {:zen/tags #{predicate}}

 any? {:zen/tags #{predicate}}

 is-event {:zen/tags #{zen/tag}}

 event
 {:zen/tags #{zen/schema}
  :type zen/map
  :keys {:type {:type zen/symbol
                :tags #{is-event}
                :zen/desc "Event type, i.e. sty/on-tests-start"}
         :ts {:type zen/integer :zen/desc "Number of milliseconds from start"}}}

 on-tests-start
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests starts"
  :confirms #{event}
  :type zen/map
  :keys {}}

 on-tests-end
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests end"
  :confirms #{event}
  :type zen/map
  :keys {}}

 on-case-start
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests finish"
  :confirms #{event}
  :type zen/map
  :keys {:env {:confirms #{env}}
         :case {:confirms #{case}}}}

 on-case-end
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests finish"
  :confirms #{event on-step-start}
  :type zen/map
  :keys {:result {:type zen/any}
         :errors {:type zen/any}}}

 on-step-start
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests finish"
  :confirms #{event}
  :type zen/map
  :keys {:env {:confirms #{env}}
         :case {:confirms #{case}}
         :step {:confirms #{step}}}}

 on-step-end
 {:zen/tags #{is-event zen/schema}
  :zen/desc "Event emited on tests finish"
  :confirms #{event on-step-start}
  :type zen/map
  :keys {:result {:type zen/any}
         :errors {:type zen/any}}}

 op  {:zen/tags #{zen/tag zen/schema}
      :type zen/map
      :keys {:params {:confirms #{zen/schema}}
             :result {:confirms #{zen/schema}}}}

 echo {:zen/tags #{op} :zen/desc "echo operation to test rpc api"}

 get-namespaces {:zen/tags #{op} :zen/desc "get namespaces with cases to run on UI"}

 get-case {:zen/tags #{op}
           :zen/desc "get stresty case to run on UI"
           :params {:type zen/map
                    :keys {:case {:type zen/string}}}}
 
 run-tests
 {:zen/tags #{op}
  :zen/desc "Run selected tests"
  :params {:type zen/map
           :keys {:tags    {:type zen/set    :every {:type zen/string}}
                  :pattern {:type zen/string}}}}

 run-cases
 {:zen/tags #{op}
  :zen/desc "Run specific cases"
  :params {:type zen/map
           :keys {:cases  {:type zen/vector :every {:type zen/symbol :tags #{case}}}
                  :envs {:type zen/vector :every {:type zen/symbol :tags #{env}}}
                  :tags {:type zen/set :every {:type zen/string}}}}}

 run-steps
 {:zen/tags #{op}
  :zen/desc "Run specific cases"
  :params {:type zen/map
           :keys {:envs {:type zen/vector :every {:type zen/symbol :tags #{env}}}
                  :case   {:type zen/symbol :tags #{case}}
                  :tags   {:type zen/set :every {:type zen/string}}
                  :steps  {:type zen/vector :every {:type zen/keyword}}}}}

 rest-op  {:zen/tags #{zen/tag}}
 index-op {:zen/tags #{rest-op}}

 rpc-op   {:zen/tags #{rpc-op}
           :zen/desc "rpc endpoint, accept json and transit formats trho content-type header"}

 get-rpc-op   {:zen/tags #{rpc-op}
               :zen/desc "rpc endpoint, accept json and transit formats trho content-type header"}

 api
 {:zen/desc "Server routes"
  :static-dir "static"
  :routes {:get index-op
           "rpc" {:post rpc-op
                  :get  get-rpc-op}}}
 cli
 {:zen/desc "CLI interface"}}
 
